#!/usr/bin/env python3.11
from abc import ABC, abstractmethod
import asyncio
import signal
import monome
from enum import Enum
import time
import random
import string
import copy
from collections import deque
import pdb
import rtmidi
from rtmidi.midiconstants import (CONTROL_CHANGE, NOTE_ON, NOTE_OFF)

# class header comment text is generated by `figlet -f jazmine text`
def generate_unique_id(existing_ids, length=6):
    while True:
        new_id = ''.join(random.choices(string.ascii_uppercase + string.digits, k=length))
        if new_id not in existing_ids:
            return new_id

"""
       8                           
       8                           
.oPYo. 8oPYo. .oPYo. .oPYo. .oPYo. 
Yb..   8    8 .oooo8 8    8 8oooo8 
  'Yb. 8    8 8    8 8    8 8.     
`YooP' 8    8 `YooP8 8YooP' `Yooo' 
:.....:..:::..:.....:8 ....::.....:
:::::::::::::::::::::8 ::::::::::::
:::::::::::::::::::::..::::::::::::
"""
class Shape(ABC):
    def __init__(self, points):
        self.points = points

    @abstractmethod
    def contains_point(self, x, y):
        pass

    @abstractmethod
    def draw(self, buffer, brightness):
        pass

class Point(Shape):
    def contains_point(self, x, y):
        return (x, y) == self.points[0]

    def draw(self, buffer, brightness):
        x, y = self.points[0]
        buffer.led_level_set(x, y, brightness)

class Rectangle(Shape):
    def contains_point(self, x, y):
        x1, y1 = self.points[0]
        x2, y2 = self.points[1]
        min_x, max_x = min(x1, x2), max(x1, x2)
        min_y, max_y = min(y1, y2), max(y1, y2)
        return min_x <= x <= max_x and min_y <= y <= max_y

    def draw(self, buffer, brightness):
        x1, y1 = self.points[0]
        x2, y2 = self.points[1]
        # Ensure we draw from the minimum to maximum coordinates
        for x in range(min(x1, x2), max(x1, x2) + 1):
            for y in range(min(y1, y2), max(y1, y2) + 1):
                buffer.led_level_set(x, y, brightness)

class Triangle(Shape):
    def contains_point(self, x, y):
        if len(self.points) < 3:
            return False
        def sign(p1, p2, p3):
            return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1])
        b1 = sign((x, y), self.points[0], self.points[1]) < 0
        b2 = sign((x, y), self.points[1], self.points[2]) < 0
        b3 = sign((x, y), self.points[2], self.points[0]) < 0
        return (b1 == b2) and (b2 == b3)

    def draw(self, buffer, brightness):
        if len(self.points) < 3:
            print(f"Warning: Triangle has insufficient points: {self.points}")
            return
        x1, y1 = self.points[0]
        x2, y2 = self.points[1]
        x3, y3 = self.points[2]
        min_x, max_x = min(x1, x2, x3), max(x1, x2, x3)
        min_y, max_y = min(y1, y2, y3), max(y1, y2, y3)
        for x in range(min_x, max_x + 1):
            for y in range(min_y, max_y + 1):
                if self.contains_point(x, y):
                    buffer.led_level_set(x, y, brightness)

"""
o    o o        8                               o  
8    8 8        8                               8  
8    8 8 .oPYo. 8 .oPYo. ooYoYo. .oPYo. odYo.  o8P 
8    8 8 8oooo8 8 8oooo8 8' 8  8 8oooo8 8' `8   8  
8    8 8 8.     8 8.     8  8  8 8.     8   8   8  
`YooP' 8 `Yooo' 8 `Yooo' 8  8  8 `Yooo' 8   8   8  
:.....:..:.....:..:.....:..:..:..:.....:..::..::..:
:::::::::::::::::::::::::::::::::::::::::::::::::::
:::::::::::::::::::::::::::::::::::::::::::::::::::
"""
class UIElementType(Enum):
    TRIGGER = 1
    TOGGLE = 2
    SLIDER = 3

class UIElement:
    next_note_number = 0
    next_cc_number = 1  # Starting from CC 1 (Modulation Wheel)

    def __init__(self, id, shape, grid_ui):
        self.id = id
        self.shape = shape
        self.grid_ui = grid_ui
        self.state = 0
        self.flash_start = 0
        self.base_brightness = 2
        self.peak_brightness = 9
        self.channel = 1  # Default MIDI channel

    def contains_point(self, x, y):
        return self.shape.contains_point(x, y)

    def touch(self, x, y, s):
        self.flash_start = time.time()
        print(f"{self.id} {s}")

    def get_brightness(self):
        return self.base_brightness if self.state == 0 else self.peak_brightness

    def clip_brightness(self):
        self.base_brightness = max(1, min(self.base_brightness, 13))
        self.peak_brightness = max(3, min(self.peak_brightness, 15))

    def adjust_brightness(self, delta):
        self.base_brightness += delta
        self.peak_brightness += delta
        self.clip_brightness()

    def draw(self, buffer):
        raise NotImplementedError("Subclasses should implement this!")

class Toggle(UIElement):
    def __init__(self, id, shape, grid_ui):
        super().__init__(id, shape, grid_ui)
        self.note_number = UIElement.next_note_number
        UIElement.next_note_number += 1

    def get_brightness(self):
        elapsed = time.time() - self.flash_start
        if self.state:  # If the toggle is on
            if elapsed < 0.5:  # Growing phase
                return int(self.base_brightness + (self.peak_brightness - self.base_brightness) * (elapsed / 0.5))
            else:
                return self.peak_brightness  # Max brightness after growing
        else:  # If the toggle is off
            if elapsed < 0.5:  # Fading out phase
                return int(self.peak_brightness * (1 - (elapsed / 0.5)))
            else:
                return self.base_brightness  # Return to base brightness when fully faded out

    def touch(self, x, y, s):
        super().touch(x,y,s)
        self.state = s
        if s == 1:
            self.send_note_on()
        else:
            self.send_note_off()

    def send_note_on(self):
        midi_message = [NOTE_ON | (self.channel - 1), self.note_number, 127]
        self.grid_ui.midiout.send_message(midi_message)
        print(f"MIDI Note On: Channel {self.channel}, Note {self.note_number}, Velocity 127")

    def send_note_off(self):
        midi_message = [NOTE_OFF | (self.channel - 1), self.note_number, 0]
        self.grid_ui.midiout.send_message(midi_message)
        print(f"MIDI Note Off: Channel {self.channel}, Note {self.note_number}, Velocity 0")

    def draw(self, buffer):
        self.shape.draw(
            buffer,
            self.get_brightness()
        )

class Trigger(UIElement):
    def __init__(self, id, shape, grid_ui):
        super().__init__(id, shape, grid_ui)
        self.note_number = UIElement.next_note_number
        UIElement.next_note_number += 1

    def touch(self, x, y, s):
        super().touch(x,y,s)
        if s == 1:
            self.state = 1
            self.send_note_on()
        else:
            self.state = 0
            self.send_note_off()

    def send_note_on(self):
        midi_message = [NOTE_ON | (self.channel - 1), self.note_number, 127]
        self.grid_ui.midiout.send_message(midi_message)
        print(f"MIDI Note On: Channel {self.channel}, Note {self.note_number}, Velocity 127")

    def send_note_off(self):
        midi_message = [NOTE_OFF | (self.channel - 1), self.note_number, 0]
        self.grid_ui.midiout.send_message(midi_message)
        print(f"MIDI Note Off: Channel {self.channel}, Note {self.note_number}, Velocity 0")

    def draw(self, buffer):
        self.shape.draw(
            buffer,
            self.get_brightness()
        )

class Slider(UIElement):
    def __init__(self, id, shape, grid_ui):
        super().__init__(id, shape, grid_ui)
        self.cc_number = UIElement.next_cc_number
        UIElement.next_cc_number += 1
        if UIElement.next_cc_number in [32, 64, 97, 120]:  # Skip reserved CC numbers
            UIElement.next_cc_number += 1

    def touch(self, x, y, s):
        super().touch(x, y, s)
        self.state = self.calculate_value(x, y)
        self.send_cc()

    def calculate_value(self, x, y):
        # Calculate the value based on the touch position
        # This is a simple linear calculation
        start_x, start_y = self.shape.points[0]
        end_x, end_y = self.shape.points[1]
        total_length = max(abs(end_x - start_x), abs(end_y - start_y))
        current_length = max(abs(x - start_x), abs(y - start_y))
        return int((current_length / total_length) * 127)

    def send_cc(self):
        midi_message = [CONTROL_CHANGE | (self.channel - 1), self.cc_number, self.state]
        self.grid_ui.midiout.send_message(midi_message)
        print(f"MIDI CC: Channel {self.channel}, CC {self.cc_number}, Value {self.state}")

    def draw(self, buffer):
        # Slider logic: draw a line or a series of points based on the current value
        # For example, we can represent the slider's value with a line of LEDs
        for i in range(self.shape.points[0][0], self.shape.points[1][0] + 1):
            brightness = self.base_brightness if self.state == 0 else self.peak_brightness
            buffer.led_level_set(i, self.shape.points[0][1], brightness)

"""
              o      8 o    o o 
                     8 8    8 8 
.oPYo. oPYo. o8 .oPYo8 8    8 8 
8    8 8  `'  8 8    8 8    8 8 
8    8 8      8 8    8 8    8 8 
`YooP8 8      8 `YooP' `YooP' 8 
:....8 ..:::::..:.....::.....:..
::ooP'.:::::::::::::::::::::::::
::...:::::::::::::::::::::::::::
"""
class GridUI(monome.GridApp):
    def __init__(self):
        super().__init__()
        self.width = 0
        self.height = 0
        self.connected = False
        self.is_running = False
        self.update_task = None
        self.meta_pressed = False
        self.selected_element = None
        self.delete_press_time = 0
        self.delete_press_count = 0
        self.paste_buffer = None
        self.paste_location = None
        self.button_history = deque(maxlen=5)  # Store last 5 button presses
        self.ui_elements = {}
        self.current_points = []
        self.midiout = rtmidi.MidiOut()
        self.open_midi_port()
        self.reset()

    def reset(self):
        self.ui_elements.clear()
        self.current_points.clear()
        self.meta_pressed = False
        self.selected_element = None
        self.delete_press_time = 0
        self.delete_press_count = 0
        self.paste_location = None
        self.button_history.clear()
        # We don't reset paste_buffer here to keep it across resets

    def on_grid_ready(self):
        self.width = self.grid.width
        self.height = self.grid.height
        self.connected = True
        print(f"Grid connected: {self.width}x{self.height}")
        self.reset()
        self.start_update_loop()
        self.draw()

    def start_update_loop(self):
        if not self.is_running:
            self.is_running = True
            self.update_task = asyncio.create_task(self.update_loop())

    async def update_loop(self):
        while self.is_running:
            self.draw()
            await asyncio.sleep(0.1)  # Update every 100ms

    def stop_update_loop(self):
        self.is_running = False
        if self.update_task:
            self.update_task.cancel()

    def cleanup(self):
        self.stop_update_loop()
        if self.connected:
            buffer = monome.GridBuffer(self.width, self.height)
            buffer.render(self.grid)
        if self.midiout:
            self.midiout.close_port()
        del self.midiout
        print("\nCleaning up and exiting...")

    def on_grid_key(self, x, y, s):
        self.button_history.append((x, y))
        
        if not self.connected:
            return

        if x == 0 and y == self.height - 1:  # Meta key
            # Set the meta key state
            self.meta_pressed = (s == 1)

            # If the meta key is released, create a UI element
            if not self.meta_pressed:
                self.create_ui_element()
                self.selected_element = None
                self.current_points.clear()

            # Redraw the grid
            self.draw()
            return

        if self.meta_pressed:
            self.handle_meta_interaction(x, y, s)
        else:
            self.handle_normal_interaction(x, y, s)

        self.draw()

    def handle_normal_interaction(self, x, y, s):
        if y == self.height - 1:  # Ignore bottom row
            return

        print(f"Normal interaction: x={x:02d}, y={y:02d}, s={s}")

        # Check if the point is inside any UI element
        for element_id, element in self.ui_elements.items():
            if element.contains_point(x, y):
                print(f'touched {element_id}')
                element.touch(x, y, s)
                break

    def handle_meta_interaction(self, x, y, s):
        if s == 1:  # Key pressed
            print(f"Meta interaction: x={x:02d}, y={y:02d}, s={s}")
            
            if y < self.height - 1:  # Exclude bottom row for UI element creation
                if (x, y) not in self.current_points:
                    self.current_points.append((x, y))
                    print(f"Added point: {(x, y)}. Current points: {self.current_points}")
                
                # Set paste location
                self.paste_location = (x, y)
            
            if self.selected_element:
                meta_ui_pos = self.get_meta_ui_position(self.selected_element)
                if (x, y) == meta_ui_pos:
                    self.selected_element.adjust_brightness(1)
                    return
                elif (x, y) == (meta_ui_pos[0] + 1, meta_ui_pos[1]):
                    self.selected_element.adjust_brightness(-1)
                    return
                elif (x, y) == (1, self.height - 1):  # Copy/Delete/Paste button
                    current_time = time.time()
                    if current_time - self.delete_press_time < 0.5:  # Double press within 0.5 seconds
                        self.delete_selected_element()
                        self.current_points.clear()
                    elif self.paste_buffer and self.paste_location:
                        self.paste_element(self.paste_location[0], self.paste_location[1])
                        self.paste_location = None
                    else:
                        self.copy_selected_element()
                    self.delete_press_time = current_time
                    return

            # If we didn't press a meta UI button, check for polygon selection
            if y < self.height - 1:  # Exclude bottom row
                element_at_position = self.get_element_at_position(x, y)
                if element_at_position:
                    if self.selected_element and self.selected_element != element_at_position:
                        self.deselect_element(self.selected_element)
                    self.selected_element = element_at_position
                    self.delete_press_count = 0  # Reset delete press count when selecting a new element
                else:
                    if self.selected_element:
                        self.deselect_element(self.selected_element)
                        self.selected_element = None

    def deselect_element(self, element):
        element.reset_brightness()
        # element.state = 0  # Reset the state of the element

    def create_ui_element(self):
        new_id = generate_unique_id(self.ui_elements.keys())
        if len(self.current_points) == 2:
            new_element = Trigger(new_id, Rectangle(self.current_points.copy()), self)
        elif len(self.current_points) == 3:
            new_element = Trigger(new_id, Triangle(self.current_points.copy()), self)
        elif len(self.current_points) == 1:
            new_element = Trigger(new_id, Point(self.current_points.copy()), self)
        else:
            print(f"Warning: Invalid number of points for UI element creation: {len(self.current_points)}")
            return

        if new_element and not self.element_in_bottom_row(new_element) and not self.elements_overlap(new_element):
            self.ui_elements[new_id] = new_element
            print(f"Created new {type(new_element).__name__} {new_element.id}")
            if isinstance(new_element, Slider):
                print(f"Assigned CC number: {new_element.cc_number}")
            else:
                print(f"Assigned note number: {new_element.note_number}")
            self.current_points.clear()  # Clear points after creating the element
        else:
            print("Cannot create UI element: it would be in the bottom row or overlap with existing elements")

    def elements_overlap(self, new_element):
        for existing_element in self.ui_elements.values():
            if self.check_overlap(new_element, existing_element):
                return True
        return False

    def check_overlap(self, elem1, elem2):
        # Check if any point of elem1 is inside elem2 or vice versa
        for point in elem1.shape.points:
            if elem2.contains_point(point[0], point[1]):
                return True
        for point in elem2.shape.points:
            if elem1.contains_point(point[0], point[1]):
                return True

        # Check if any edges intersect
        edges1 = self.get_edges(elem1.shape.points)
        edges2 = self.get_edges(elem2.shape.points)
        for edge1 in edges1:
            for edge2 in edges2:
                if self.lines_intersect(edge1, edge2):
                    return True

        return False

    def get_edges(self, points):
        edges = []
        for i in range(len(points)):
            edges.append((points[i], points[(i + 1) % len(points)]))
        return edges

    def lines_intersect(self, line1, line2):
        x1, y1 = line1[0]
        x2, y2 = line1[1]
        x3, y3 = line2[0]
        x4, y4 = line2[1]

        def ccw(A, B, C):
            return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])

        return ccw((x1, y1), (x3, y3), (x4, y4)) != ccw((x2, y2), (x3, y3), (x4, y4)) and \
               ccw((x1, y1), (x2, y2), (x3, y3)) != ccw((x1, y1), (x2, y2), (x4, y4))

    def copy_selected_element(self):
        if self.selected_element:
            self.paste_buffer = copy.deepcopy(self.selected_element)
            print("Element copied to paste buffer")

    def delete_selected_element(self):
        if self.selected_element:
            element_to_delete = None
            for element_id, element in self.ui_elements.items():
                if element == self.selected_element:
                    element_to_delete = element_id
                    break
            if element_to_delete:
                del self.ui_elements[element_to_delete]
            self.selected_element = None
            print("Element deleted")

    def paste_element(self, x, y):
        if not self.paste_buffer:
            return

        new_element = copy.deepcopy(self.paste_buffer)
        
        # Calculate the offset to move the element
        old_x, old_y = new_element.shape.points[0]
        offset_x, offset_y = x - old_x, y - old_y

        # Move the element
        new_element.shape.points = [(p[0] + offset_x, p[1] + offset_y) for p in new_element.shape.points]

        # Check if the new element would be in the bottom row or overlap with existing elements
        if self.element_in_bottom_row(new_element) or self.elements_overlap(new_element):
            print("Cannot paste: element would be in bottom row or overlap with existing elements")
            return

        new_id = generate_unique_id(self.ui_elements.keys())
        self.ui_elements[new_id] = new_element
        self.selected_element = new_element
        print(f"Element pasted at ({x}, {y})")

    def element_in_bottom_row(self, element):
        return any(point[1] == self.height - 1 for point in element.shape.points)

    def get_element_at_position(self, x, y):
        for element in self.ui_elements.values():
            if element.contains_point(x, y):
                return element
        return None

    def get_meta_ui_position(self, element):
        # Find the rightmost point of the element
        max_x = max(point[0] for point in element.shape.points)
        min_y = min(point[1] for point in element.shape.points)

        # Position the meta UI to the right of the element
        meta_x = max_x + 1
        meta_y = min_y

        # If the meta UI would be off the grid, move it left
        if meta_x >= self.width - 1:
            meta_x = max_x - 2

        # Ensure the meta UI is fully on the grid
        meta_x = max(0, min(self.width - 2, meta_x))
        meta_y = max(0, min(self.height - 1, meta_y))

        return (meta_x, meta_y)

    def draw(self):
        if not self.connected:
            return
        
        buffer = monome.GridBuffer(self.width, self.height)

        # Draw UI elements
        for element in self.ui_elements.values():
            element.draw(buffer)

        # Draw current selection
        for point in self.current_points:
            buffer.led_level_set(point[0], point[1], 15)

        # Draw meta key
        buffer.led_level_set(0, self.height - 1, 8 if self.meta_pressed else 1)

        # Draw meta UI if an element is selected
        if self.meta_pressed and self.selected_element:
            meta_ui_pos = self.get_meta_ui_position(self.selected_element)
            buffer.led_level_set(meta_ui_pos[0], meta_ui_pos[1], 15)  # Increment brightness
            buffer.led_level_set(meta_ui_pos[0] + 1, meta_ui_pos[1], 15)  # Decrement brightness
            
            # Draw copy/delete/paste button
            copy_delete_paste_brightness = 15 if self.paste_buffer else 8
            buffer.led_level_set(1, self.height - 1, copy_delete_paste_brightness)

        # Draw paste location indicator
        if self.meta_pressed and self.paste_buffer and self.paste_location:
            buffer.led_level_set(self.paste_location[0], self.paste_location[1], 15)

        buffer.render(self.grid)

    def open_midi_port(self):
        available_ports = self.midiout.get_ports()
        if available_ports:
            self.midiout.open_port(0)  # Open the first available port
            print(f"Opened MIDI port: {available_ports[0]}")
        else:
            self.midiout.open_virtual_port("GridUI MIDI")
            print("Opened virtual MIDI port: GridUI MIDI")

"""
                 o         o    o o 
                 8         8    8 8 
ooYoYo. .oPYo.  o8P .oPYo. 8    8 8 
8' 8  8 8oooo8   8  .oooo8 8    8 8 
8  8  8 8.       8  8    8 8    8 8 
8  8  8 `Yooo'   8  `YooP8 `YooP' 8 
..:..:..:.....:::..::.....::.....:..
::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::
"""
class MetaUI:
    def __init__(self, grid_ui):
        self.grid_ui = grid_ui
        self.paste_buffer = grid_ui.paste_buffer
        self.paste_location = grid_ui.paste_location
        self.selected_element = grid_ui.selected_element

    def handle_meta_interaction(self, x, y, s):
        if s == 1:  # Key pressed
            print(f"Meta interaction: x={x}, y={y}")
            
            if y < self.grid_ui.height - 1:  # Exclude bottom row for UI element creation
                if (x, y) not in self.grid_ui.current_points:
                    self.grid_ui.current_points.append((x, y))
                    print(f"Added point: {(x, y)}. Current points: {self.grid_ui.current_points}")
                
                # Set paste location
                self.grid_ui.paste_location = (x, y)
            
            if self.grid_ui.selected_element:
                meta_ui_pos = self.grid_ui.get_meta_ui_position(self.grid_ui.selected_element)
                if (x, y) == meta_ui_pos:
                    self.grid_ui.selected_element.adjust_brightness(1)
                    return
                elif (x, y) == (meta_ui_pos[0] + 1, meta_ui_pos[1]):
                    self.grid_ui.selected_element.adjust_brightness(-1)
                    return
                elif (x, y) == (1, self.grid_ui.height - 1):  # Copy/Delete/Paste button
                    current_time = time.time()
                    if current_time - self.grid_ui.delete_press_time < 0.5:  # Double press within 0.5 seconds
                        self.grid_ui.delete_selected_element()
                        self.grid_ui.current_points.clear()
                    elif self.grid_ui.paste_buffer and self.grid_ui.paste_location:
                        self.grid_ui.paste_element(self.grid_ui.paste_location[0], self.grid_ui.paste_location[1])
                        self.grid_ui.paste_location = None
                    else:
                        self.grid_ui.copy_selected_element()
                    self.grid_ui.delete_press_time = current_time
                    return

            # If we didn't press a meta UI button, check for polygon selection
            if y < self.grid_ui.height - 1:  # Exclude bottom row
                element_at_position = self.grid_ui.get_element_at_position(x, y)
                if element_at_position:
                    if self.grid_ui.selected_element and self.grid_ui.selected_element != element_at_position:
                        self.grid_ui.deselect_element(self.grid_ui.selected_element)
                    self.grid_ui.selected_element = element_at_position
                    self.grid_ui.delete_press_count = 0  # Reset delete press count when selecting a new element
                else:
                    if self.grid_ui.selected_element:
                        self.grid_ui.deselect_element(self.grid_ui.selected_element)
                        self.grid_ui.selected_element = None

    def handle_meta_release(self):
        # Handle any actions needed when meta key is released
        pass  # Placeholder for future functionality

    def draw(self, buffer, selected_element):
        meta_ui_pos = self.grid_ui.get_meta_ui_position(selected_element)
        buffer.led_level_set(meta_ui_pos[0], meta_ui_pos[1], 15)  # Increment brightness
        buffer.led_level_set(meta_ui_pos[0] + 1, meta_ui_pos[1], 15)  # Decrement brightness
        
        # Draw copy/delete/paste button
        copy_delete_paste_brightness = 15 if self.grid_ui.paste_buffer else 8
        buffer.led_level_set(1, self.grid_ui.height - 1, copy_delete_paste_brightness)

    def cleanup(self):
        # Implement any cleanup if necessary
        pass

"""
                o       
                        
ooYoYo. .oPYo. o8 odYo. 
8' 8  8 .oooo8  8 8' `8 
8  8  8 8    8  8 8   8 
8  8  8 `YooP8  8 8   8 
..:..:..:.....::....::..
::::::::::::::::::::::::
::::::::::::::::::::::::
"""
async def main():
    """
    Callback function for when a serialosc device is added.
    Arguments:
        id (str): The device ID
        type (str): The device type
        port (int): The port number for the device
    Returns: None
    """
    def serialosc_device_added(id, type, port):
        print(f'connecting to {id} ({type}) on port {port}')
        asyncio.ensure_future(grid_studies.grid.connect('127.0.0.1', port))

    """
    Handles the SIGINT signal (Ctrl+C) to gracefully exit the program.
    Arguments: signum (int) - The signal number
               frame (frame object) - Current stack frame
    Returns: None
    """
    def signal_handler(signum, frame):
        print("\nCtrl+C pressed. Cleaning up...")
        grid_studies.cleanup()
        loop.stop()

    loop = asyncio.get_running_loop()
    grid_studies = GridUI()

    serialosc = monome.SerialOsc()
    serialosc.device_added_event.add_handler(serialosc_device_added)

    await serialosc.connect()

    signal.signal(signal.SIGINT, signal_handler)

    try:
        await loop.create_future()
    finally:
        grid_studies.cleanup()

    await loop.create_future()

if __name__ == '__main__':
    asyncio.run(main())
